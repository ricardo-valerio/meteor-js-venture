)]}'
{"version":3,"sources":["aldeed:template-extension/template-extension.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mD;;AAEA,qD;AACA,6D;AACA,+D;;AAEA,mC;AACA,yD;AACA,sC;AACA,4B;AACA,wC;AACA,6B;AACA,K;AACA,G;;AAEA,wC;AACA,sE;AACA,mD;AACA,6B;AACA,2B;AACA,qC;AACA,6B;AACA,mC;AACA,uC;AACA,gC;AACA,kC;AACA,2B;AACA,W;AACA,gB;AACA,yB;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,0C;AACA,qC;AACA,E;;AAEA,2C;AACA,sC;AACA,E;;AAEA,4C;AACA,uC;AACA,E;;AAEA,6C;AACA,kB;;AAEA,kC;AACA,oI;AACA,G;;AAEA,sC;;AAEA,oE;AACA,8B;AACA,c;AACA,+C;AACA,wB;AACA,4C;AACA,kE;AACA,kD;AACA,K;AACA,G;AACA,E;;AAEA,+D;AACA,kB;AACA,sC;;AAEA,+C;AACA,kD;;AAEA,4B;AACA,sG;AACA,a;AACA,K;;AAEA,oE;AACA,I;;AAEA,6D;AACA,wC;AACA,4D;AACA,0D;AACA,kC;AACA,O;AACA,U;AACA,wC;AACA,G;AACA,E;;AAEA,uE;AACA,kB;AACA,sC;AACA,oC;;AAEA,gD;AACA,+C;AACA,yB;AACA,mH;AACA,a;AACA,K;;AAEA,kC;AACA,6F;AACA,K;;AAEA,U;AACA,kD;AACA,oC;AACA,wH;AACA,6C;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,iD;AACA,qC;AACA,+C;AACA,2B;AACA,O;AACA,0C;AACA,sC;AACA,G;AACA,E;;AAEA,sE;AACA,kB;;AAEA,sC;;AAEA,+C;AACA,mD;AACA,+C;AACA,yB;AACA,kH;AACA,a;AACA,K;AACA,qB;AACA,wD;AACA,+C;AACA,O;AACA,I;;AAEA,iD;AACA,qC;AACA,+C;AACA,0B;AACA,O;AACA,0C;AACA,qC;AACA,G;AACA,E;;AAEA,qE;AACA,kB;AACA,sC;;AAEA,6C;AACA,mD;AACA,+C;AACA,yB;AACA,iH;AACA,a;AACA,K;AACA,+D;AACA,gD;AACA,kC;AACA,yB;;AAEA,mF;AACA,uC;AACA,oD;AACA,gD;AACA,qC;AACA,+D;AACA,oE;AACA,mB;AACA,6C;AACA,S;AACA,O;AACA,I;;AAEA,iD;AACA,qC;AACA,+C;AACA,yB;AACA,O;AACA,0C;AACA,oC;AACA,G;AACA,E;;AAEA,wD;AACA,+B;AACA,E;AACA,mD;AACA,qB;AACA,2F;;AAEA,wC;AACA,0C;AACA,yC;AACA,wC;;AAEA,uB;AACA,I;;AAEA,wC;AACA,mC;AACA,6C;AACA,6C;AACA,gE;AACA,4B;AACA,O;AACA,kB;AACA,wC;AACA,sD;AACA,gC;AACA,oB;AACA,G;AACA,E;;AAEA,8E;AACA,mF;AACA,iF;AACA,6E;AACA,mF;AACA,mF;AACA,mC;AACA,6D;AACA,sB;;AAEA,oB;AACA,gC;AACA,iC;AACA,K;AACA,wC;AACA,G;AACA,E;;AAEA,+E;AACA,gF;AACA,0E;AACA,mD;AACA,iF;AACA,uE;AACA,uB;AACA,e;AACA,G;;AAEA,Y;AACA,sB;AACA,kC;AACA,8D;AACA,yE;AACA,0E;AACA,6E;AACA,wE;AACA,mD;AACA,K;AACA,gB;AACA,kB;AACA,K;AACA,8D;AACA,0D;AACA,4F;AACA,Q;AACA,G;AACA,kB;AACA,E;;AAEA,iE;AACA,sE;AACA,2C;AACA,yD;AACA,sE;AACA,qC;AACA,wD;AACA,G;;AAEA,sC;AACA,0B;AACA,yC;AACA,I;AACA,mB;AACA,yC;AACA,6C;AACA,G;;AAEA,iD;AACA,wD;AACA,4B;AACA,yC;AACA,+B;AACA,E;;AAEA,wC;;AAEA,a;;AAEA,qC;AACA,8E;AACA,4B;;AAEA,qE;AACA,qB;AACA,mC;AACA,4C;AACA,gE;AACA,yC;AACA,G;;AAEA,2D;AACA,2D;AACA,oC;AACA,0C;AACA,wD;AACA,4C;AACA,I;;AAEA,kD;AACA,C;;AAEA,mC;AACA,2D;AACA,8D;AACA,uD;AACA,iE;AACA,W;AACA,kD;AACA,uC;AACA,iC;AACA,O;AACA,G;AACA,C;;AAEA,gD;AACA,4B;AACA,sD;AACA,G;AACA,Q;AACA,2B;AACA,G;AACA,C;;AAEA,0B;AACA,c;AACA,W;AACA,G;AACA,yD;AACA,2B;AACA,mC;AACA,qC;AACA,G;AACA,c;AACA,C;;AAEA,+C;AACA,8C;AACA,4B;AACA,+B;AACA,G;AACA,C;;AAEA,iD;AACA,6G;AACA,4B;AACA,4B;AACA,+B;AACA,G;AACA,C","file":"/packages/aldeed:template-extension.js","sourcesContent":["/* global Meteor, Template, _, Blaze, $, Tracker */\n\nvar hookTypes = [\"created\", \"rendered\", \"destroyed\"];\nvar globalHooks = {created: [], rendered: [], destroyed: []};\nvar templateHooks = {created: {}, rendered: {}, destroyed: {}};\n\n// Setup for multiple hooks support\n// We assume that no other code will be directly defining\n// a hook once the client has started.\nMeteor.startup(function () {\n  Template.forEach(function (template) {\n    defineAllHooks(template);\n  });\n});\n\nTemplate.forEach = function (callback) {\n  // for some reason we get the \"body\" template twice when looping, so\n  // we track that and only call the callback once.\n  var alreadyDidBody = false;\n  for (var t in Template) {\n    if (Template.hasOwnProperty(t)) {\n      var tmpl = Template[t];\n      if (Blaze.isTemplate(tmpl)) {\n        if (tmpl.viewName === \"body\") {\n          if (!alreadyDidBody) {\n            alreadyDidBody = true;\n            callback(tmpl);\n          }\n        } else {\n          callback(tmpl);\n        }\n      }\n    }\n  }\n};\n\nTemplate.onCreated = function (callback) {\n  globalHooks.created.push(callback);\n};\n\nTemplate.onRendered = function (callback) {\n  globalHooks.rendered.push(callback);\n};\n\nTemplate.onDestroyed = function (callback) {\n  globalHooks.destroyed.push(callback);\n};\n\nTemplate.prototype.hooks = function (hooks) {\n  var self = this;\n\n  if (typeof hooks !== \"object\") {\n    throw new Error(\"hooks argument must be an object with created, rendered, and/or destroyed properties, each set to a function\");\n  }\n\n  var name = parseName(self.viewName);\n\n  // Store a reference to the hooks so they can be called by our own\n  // already defined callbacks\n  var i, type;\n  for (i = hookTypes.length - 1; i >= 0; i--) {\n    type = hookTypes[i];\n    if (typeof hooks[type] === \"function\") {\n      templateHooks[type][name] = templateHooks[type][name] || [];\n      templateHooks[type][name].push(hooks[type]);\n    }\n  }\n};\n\nTemplate.prototype.replaces = function (replacedTemplateName) {\n  var self = this;\n  var name = parseName(self.viewName);\n\n  var replaceRender = function (templateName) {\n    var replacedTemplate = Template[templateName];\n\n    if (!replacedTemplate) {\n      console.warn(\"Can't replace template \" + templateName + \" because it hasn't been defined yet.\");\n      return;\n    }\n\n    replacedTemplate.renderFunction = Template[name].renderFunction;\n  };\n\n  // Allow this method to be called with an array or a string\n  if (_.isArray(replacedTemplateName)) {\n    // If called with array, iterate over the template names\n    _.each(replacedTemplateName, function (templateName) {\n      replaceRender(templateName);\n    });\n  } else {\n    replaceRender(replacedTemplateName);\n  }\n};\n\nTemplate.prototype.inheritsHelpersFrom = function (otherTemplateName) {\n  var self = this;\n  var name = parseName(self.viewName);\n  var thisTemplate = Template[name];\n\n  var inheritHelpers = function (templateName) {\n    var otherTemplate = Template[templateName];\n    if (!otherTemplate) {\n      console.warn(\"Can't inherit helpers from template \" + templateName + \" because it hasn't been defined yet.\");\n      return;\n    }\n\n    if (otherTemplate.__helpers) {\n      thisTemplate.__helpers = $.extend({}, thisTemplate.__helpers, otherTemplate.__helpers);\n    }\n\n    else {\n      // backwards compatibility; pre-0.9.4 Meteor\n      for (var h in otherTemplate) {\n        if (otherTemplate.hasOwnProperty(h) && (h.slice(0, 2) !== \"__\") && h !== \"viewName\" && h !== \"renderFunction\") {\n          thisTemplate[h] = otherTemplate[h];\n        }\n      }\n    }\n  };\n\n  //Accept an array as otherTemplateName argument\n  if (_.isArray(otherTemplateName)) {\n    _.each(otherTemplateName, function (name) {\n      inheritHelpers(name);\n    });\n  } else { //otherTemplateName is a string\n    inheritHelpers(otherTemplateName);\n  }\n};\n\nTemplate.prototype.inheritsEventsFrom = function (otherTemplateName) {\n  var self = this;\n\n  var name = parseName(self.viewName);\n\n  var inheritEvents = function (templateName) {\n    // Check for existence of templateName template\n    var otherTemplate = Template[templateName];\n    if (!otherTemplate) {\n      console.warn(\"Can't inherit events from template \" + templateName + \" because it hasn't been defined yet.\");\n      return;\n    }\n    // Inherit events\n    _.each(otherTemplate.__eventMaps, function (event) {\n      Template[name].__eventMaps.push(event);  \n    });\n  };\n\n  //Accept an array as otherTemplateName argument\n  if (_.isArray(otherTemplateName)) {\n    _.each(otherTemplateName, function (name) {\n      inheritEvents(name);\n    });\n  } else { //otherTemplateName is a string\n    inheritEvents(otherTemplateName);\n  }\n};\n\nTemplate.prototype.inheritsHooksFrom = function (otherTemplateName) {\n  var self = this;\n  var name = parseName(self.viewName);\n\n  var inheritHooks = function(templateName) {\n    // Check for existence of templateName template\n    var otherTemplate = Template[templateName];\n    if (!otherTemplate) {\n      console.warn(\"Can't inherit hooks from template \" + templateName + \" because it hasn't been defined yet.\");\n      return;\n    }\n    // For this to work properly, need to ensure that we've run\n    // defineAllHooks for both templates already\n    defineAllHooks(otherTemplate);\n    defineAllHooks(self);\n\n    // For each hookType check if there are existing templateHooks for templateName\n    _.each(hookTypes, function (type) {\n      var hooks = templateHooks[type][templateName];\n      // For each existing hook for templateName\n      _.each(hooks, function (hook) {\n        // Initialize the target template's templateHooks array\n        templateHooks[type][name] = templateHooks[type][name] || [];\n        // Add hook\n        templateHooks[type][name].push(hook);\n      });\n    });\n  };\n\n  //Accept an array as otherTemplateName argument\n  if (_.isArray(otherTemplateName)) {\n    _.each(otherTemplateName, function (name) {\n      inheritHooks(name);\n    });\n  } else { //otherTemplateName is a string\n    inheritHooks(otherTemplateName);\n  }\n};\n\nTemplate.prototype.copyAs = function (newTemplateName) {\n  var self = this, result = [];\n  \n  var createNewTemplate = function (templateName) {\n    var newTemplate =\n    Template[templateName] = new Template('Template.' + templateName, self.renderFunction);\n\n    var name = parseName(self.viewName);\n    newTemplate.inheritsHelpersFrom(name);\n    newTemplate.inheritsEventsFrom(name);\n    newTemplate.inheritsHooksFrom(name);\n\n    return newTemplate;\n  };\n\n  //Check if newTemplateName is an array\n  if (_.isArray(newTemplateName)) {\n    _.each(newTemplateName, function (name) {\n      var template = createNewTemplate(name);\n      //Push newly created template into array that we'll return\n      result.push(template);\n    });\n    return result;\n  } else { //newTemplateName is a string\n    var template = createNewTemplate(newTemplateName);\n    //return newly created array\n    return template;\n  }\n};\n\n// Allow easy access to a template instance field when you do not know exactly\n// on which instance (this, or parent, or parent's parent, ...) a field is defined.\n// This allows easy restructuring of templates in HTML, moving things to included\n// templates without having to change everywhere in the code instance levels.\n// It also allows different structures of templates, when once template is included\n// at one level, and some other time at another. Levels do not matter anymore, just\n// that the field exists somewhere.\nBlaze.TemplateInstance.prototype.get = function (fieldName) {\n  var template = this;\n\n  while (template) {\n    if (fieldName in template) {\n      return template[fieldName];\n    }\n    template = template.parent(1, true);\n  }\n};\n\n// Access parent template instance. \"height\" is the number of levels beyond the\n// current template instance to look. By default block helper template instances\n// are skipped, but if \"includeBlockHelpers\" is set to true, they are not.\n// See https://github.com/meteor/meteor/issues/3071\nBlaze.TemplateInstance.prototype.parent = function(height, includeBlockHelpers) {\n  // If height is null or undefined, we default to 1, the first parent.\n  if (height == null) {\n    height = 1;\n  }\n\n  var i = 0;\n  var template = this;\n  while (i < height && template) {\n    var view = parentView(template.view, includeBlockHelpers);\n    // We skip contentBlock views which are injected by Meteor when using\n    // block helpers (in addition to block helper view). This matches more\n    // the visual structure of templates and not the internal implementation.\n    while (view && (!view.template || view.name === '(contentBlock)')) {\n      view = parentView(view, includeBlockHelpers);\n    }\n    if (!view) {\n      return null;\n    }\n    // Body view has template field, but not templateInstance,\n    // which more or less signals that we reached the top.\n    template = typeof view.templateInstance === 'function' ? view.templateInstance() : null;\n    i++;\n  }\n  return template;\n};\n\n// Allow to specify a function to test parent data for at various\n// levels, instead of specifying a fixed number of levels to traverse.\nvar originalParentData = Blaze._parentData;\nBlaze._parentData = function (height, _functionWrapped) {\n  // If height is not a function, simply call original implementation.\n  if (typeof height !== 'function') {\n    return originalParentData(height, _functionWrapped);\n  }\n\n  var theWith = Blaze.getView('with');\n  var test = function () {\n    return height(theWith.dataVar.get());\n  };\n  while (theWith) {\n    if (Tracker.nonreactive(test)) break;\n    theWith = Blaze.getView(theWith, 'with');\n  }\n\n  // _functionWrapped is internal and will not be\n  // specified with non numeric height, so we ignore it.\n  if (!theWith) return null;\n  // This registers a Tracker dependency.\n  return theWith.dataVar.get();\n};\n\nTemplate.parentData = Blaze._parentData;\n\n/* PRIVATE */\n\nfunction defineHook(template, type) {\n  // see if there's an existing callback set directly on the template instance\n  var orig = template[type];\n\n  // Basically scraping callbacks set directly on instance and saving\n  // in templateHooks\n  if (typeof orig === 'function') {\n    var name = parseName(template.viewName);\n    templateHooks[type][name] = templateHooks[type][name] || [];\n    templateHooks[type][name].push(orig);\n  }\n\n  // set our own callback directly on the template instance\n  template[type] = function templateExtensionMasterHook() {\n    // call all defined global hooks\n    runGlobalHooks(type, this, arguments);\n    // call all defined hooks for this template instance\n    runTemplateHooks(type, this, arguments);\n  };\n\n  template._hasTemplateExtensionMasterHook = true;\n}\n\nfunction defineAllHooks(template) {\n  // For each hookType, define the hooks for this template.\n  // Since we might call this multiple times from startup code\n  // and other functions, make sure we do it only once.\n  // Doing it twice would create an infinite loop of self-calling\n  // hooks.\n  if (!template._hasTemplateExtensionMasterHook) {\n    _.each(hookTypes, function (type) {\n      defineHook(template, type);\n    });\n  }\n}\n\nfunction parentView(view, includeBlockHelpers) {\n  if (includeBlockHelpers) {\n    return view.originalParentView || view.parentView;\n  }\n  else {\n    return view.parentView;\n  }\n}\n\nfunction parseName(name) {\n  if (!name) {\n    return;\n  }\n  // post 0.9.1 kludge to get template name from viewName\n  var prefix = 'Template.';\n  if (name.indexOf(prefix) === 0) {\n    return name.slice(prefix.length);\n  }\n  return name;\n}\n\nfunction runGlobalHooks(type, template, args) {\n  var i, h = globalHooks[type], hl = h.length;\n  for (i = 0; i < hl; i++) {\n    h[i].apply(template, args);\n  }\n}\n\nfunction runTemplateHooks(type, template, args) {\n  var i, name = parseName(template.viewName) || parseName(template.view.name), h = templateHooks[type][name];\n  var hl = h ? h.length : 0;\n  for (i = 0; i < hl; i++) {\n    h[i].apply(template, args);\n  }\n}\n"]}