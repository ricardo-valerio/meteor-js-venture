{"version":3,"file":"/packages/tmeasday:publish-counts.js","sources":["tmeasday:publish-counts/publish-counts.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,sB;AACA,c;AACA,0D;AACA,kB;AACA,4B;AACA,e;AACA,4B;;AAEA,4D;AACA,oG;AACA,I;AACA,qC;AACA,oB;;AAEA,0D;AACA,2D;AACA,qC;AACA,oF;AACA,I;AACA,qB;AACA,mC;AACA,2C;AACA,qD;AACA,mB;;AAEA,+D;AACA,2B;AACA,gB;AACA,qB;AACA,S;AACA,Q;AACA,2B;AACA,yD;AACA,Q;AACA,qC;AACA,gG;AACA,uD;AACA,O;AACA,M;;AAEA,uC;AACA,gD;AACA,mD;AACA,iB;;AAEA,2D;AACA,iC;AACA,wB;AACA,Q;AACA,uD;AACA,Q;AACA,K;;AAEA,yD;AACA,4D;AACA,4B;AACA,qB;AACA,K;;AAEA,8B;AACA,gD;;AAEA,qC;AACA,mD;AACA,K;AACA,0B;AACA,mB;;AAEA,yB;;AAEA,4B;AACA,iB;AACA,sB;AACA,O;;AAEA,Y;AACA,wB;AACA,qB;AACA,wB;AACA,6B;AACA,S;AACA,O;AACA,M;AACA,I;AACA,uB;AACA,gC;AACA,C;;AAEA,sB;AACA,0C;;AAEA,+B;AACA,mC;AACA,gC;AACA,I;AACA,E;AACA,yD;AACA,4B;AACA,K;AACA,C","sourcesContent":["if (Meteor.isServer) {\n  Counts = {};\n  Counts.publish = function(self, name, cursor, options) {\n    var count = 0;\n    var initializing = true;\n    var handle;\n    options = options || {};\n\n    if (options.countFromFieldLength && options.nonReactive)\n      throw new Error(\"options.nonReactive is not yet supported with options.countFromFieldLength\");\n    \n    if (options.countFromFieldLength)\n      var prev = {};\n\n    // ensure the cursor doesn't fetch more than it has to\n    cursor._cursorDescription.options.fields = {_id: true};\n    if (options.countFromFieldLength)\n      cursor._cursorDescription.options.fields[options.countFromFieldLength] = true;\n    \n    var observers = {\n      added: function(id, fields) {\n        if (options.countFromFieldLength) {\n          if (! fields[options.countFromFieldLength])\n            return;\n\n          count += fields[options.countFromFieldLength].length;\n          prev[id] = count;\n        } else {\n          count += 1;\n        }\n        \n        if (! initializing)\n          self.changed('counts', name, { count: count });\n      },\n      removed: function(id, fields) {\n        count -= options.countFromFieldLength ? fields[options.countFromFieldLength].length : 1;\n        self.changed('counts', name, { count: count });\n      }\n    };\n\n    if (options.countFromFieldLength) {\n      observers.changed = function(id, fields) {\n        if (! fields[options.countFromFieldLength])\n          return;\n\n        next = fields[options.countFromFieldLength].length;\n        count += next - prev[id];\n        prev[id] = next;\n        \n        self.changed('counts', name, { count: count });\n      };\n    }\n\n    if (! options.countFromFieldLength && initializing) {\n      self.added('counts', name, { count: cursor.count() });\n      if (! options.noReady)\n        self.ready();\n    }\n\n    if (! options.nonReactive)\n      handle = cursor.observeChanges(observers);\n\n    if (options.countFromFieldLength)\n      self.added('counts', name, { count: count });\n     \n    if (! options.noReady)\n      self.ready();\n\n    initializing = false;\n\n    self.onStop(function() {\n      if (handle)\n        handle.stop();\n    });\n\n    return {\n      stop: function() {\n        if (handle) {\n          handle.stop();\n          handle = undefined;\n        }\n      }\n    };\n  };\n  // back compatibility\n  publishCount = Counts.publish;\n}\n\nif (Meteor.isClient) {\n  Counts = new Mongo.Collection('counts');\n\n  Counts.get = function(name) {\n    var count = this.findOne(name);\n    return count && count.count;\n  };\n  \n  UI.registerHelper('getPublishedCount', function(name) {\n    return Counts.get(name);\n  });\n}\n"]}